## 이진 탐색 트리

1. 데이터 삽입(O)
2. 전위, 중위, 후위 탐색 출력, 깊이 출력
3. 데이터 검색
4. 데이터 삭제
- 4번은 어려울 것으로 예상. 가능한 강사님이 진행하고나서 해보는 것을 추천
- 오늘내일로는 이진탐색트리 완성이 아니라서 체크박스 체크는 추후에 완성 하고 하는걸로!

- (과제) Clear함수 재귀로 구현 (O)
- 링크드 리스트 front, back 구현 후 BFS와 DFS 출력

- iterator 구현
- begin, end 구현
- > 연산자 오버로딩 구현
- 중위순회 ++ -- 오버로딩 구현

---

1. 클래스, 구조체와 멤버

### Pair (struct)(O)

	- 멤버
		1) 탐색 시 사용되는 키 값
		2) 실제 데이터

### Node (struct)(O)

	- 멤버 
		1) Pair의 데이터를 담고 있는 공간
		2) 인덱스 별로 다른 Node의 주소를 담고있는 Node*[3]배열
			0 -> 부모 노드
			1 -> 왼 쪽 자식 노드
			2 -> 오른 쪽 자식 노드

### BST (class) - Binary Search Tree, 이진 탐색 트리(O)

	 - 멤버
		1) 루트 노드의 주소 (O)
			루트 노드부터 차근차근 내려가면서 접근
		2) 데이터의 개수 (O)
			데이터가 추가될 때 마다 개수가 증가하겠죠? 근데 어디에 쓰일지는 구현하면서 알아봐야겠음... 기억이 안나네요.


2. 함수 설계

### BST.insert(Pair) (O)

	이진 트리에는 데이터를 삽입할 때 insert() 함수를 사용.
	insert함수에 키 값과 데이터를 묶은 Pair를 인자로 넣어주면, 
	인자로 들어온 데이터를 이진 탐색 트리의 데이터 저장 구조인 Node에 삽입하고, 
	Node에 들어있는 Pair의 키 값을 기준으로 데이터를 탐색해 알맞은 자리에 저장한다.


### BST(), ~BST (O)
	
	생성자와 소멸자
	기본 생성자에는 딱히 해 줄 일이 없다.
	그냥 모든 인자를 nullptr로 초기화 해주면 되는거 아닐까?

	소멸자에는 모든 데이터를 삭제하는 BST.clear() 함수를 따로 구현하고, 그 함수가 들어간다.

### Node(), ~Node() (O)
	
	생성자와 소멸자
	기본 생성자에는 모든 인자를 nullptr로 초기화 해주면 될 듯 

	생성자 오버로딩으로 인자가 들어오는 버전을 만들자. insert 함수에서 쓸만할 것 같다...

	소멸자에는 할 일이 없다.
	차피 동적 할당 될 것이고 clear() 함수를 통해서 싹 다 날려버리기 때문이다.

### clear()

	BST의 소멸자로 사용 될 수 있고, 따로 호출해 사용할 수도 있다.
	만약 타겟의 왼 쪽 노드가 nullptr이 아니라면, 
		왼 쪽 노드의 주소를 인자로 넣고 재귀 함수를 실행한다.
	만약 타겟의 오른 쪽 노드가 nullptr이 아니라면, 
		오른 쪽 노드의 주소를 인자로 넣고 재귀 함수를 실행한다.

	이후, 자신이 들고있는 데이터를 delete해준다.

	이후, 함수를 종료하고 
	호출 된 스택을 차례차례 정리하면서 모든 데이터를 delete해준다.

---

### find(T2);

### erase(iterator); 
	
	지우고, 중위 후속자 기준 다음 데이터를 반환해주어야 한다.
	노드를 지우고 나서 나의 중위 후속자가 내 노드의 위치로 옮겨져야 한다.

	지워야 하는 타겟 노드를 인자로 받아올 때,

	1. 자식 노드가 단 하나도 없을 때
		
		1)만약 루트 노드라면
			타겟을 delete한다.
			BST가 가리키는 루트 노드를 nullptr로 만든다.
			데이터 개수를 감소시키고 
			end iterator를 반환한다.
		
		2)만약 루트 노드가 아니라면 (타겟의 부모가 있다면)
			새로운 변수(successor)에 타겟의 중위 후속자 노드의 주소를 담는다.
			부모 노드의 자식 노드가 타겟인 상태일 때,
			부모 노드가 타겟을 가리키지 못 하도록 끊어준다.	
	타겟을 delete한다.			
	데이터 개수를 감소시킨다.
	받아놓았던 중위 후속자를 가리키는 iterator를 반환한다.

	2. 자식 노드가 단 하나 있을 때
		
		새로운 변수(successor)에 타겟의 중위 후속자 노드의 주소를 담는다.
		(자식) 변수에 타겟이 가리키는 자신의 자식 노드의 주소를 담는다. 
		1) 만약 루트 노드라면
			
			i. 만약 타겟이 왼 쪽 자식을 가질 경우
				왼 쪽 자식의 부모(타겟)를 가리키지 못 하도록 nullptr로 끊어준다.
				BST가 가리키는 루트 노드를 타겟의 왼 쪽 자식으로 만든다.
			
			ii. 만약 타겟이 오른 쪽 자식을 가질 경우
				오른 쪽 자식의 부모(타겟)를 가리키지 못 하도록 nullptr로 끊어준다.
				BST가 가리키는 루트 노드를 타겟의 오른 쪽 자식으로 만든다.
		
		2) 만약 루트 노드가 아니고, 부모가 있는 상태라면
			
			목표: 타겟의 부모와 자식을 이어주어야 한다.

			i. 만약 타겟이 왼 쪽 자식을 가질 경우