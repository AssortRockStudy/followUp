## 이진 탐색 트리

1. 데이터 삽입(O)
2. 전위, 중위, 후위 탐색 출력, 깊이 출력
3. 데이터 검색
4. 데이터 삭제
- 4번은 어려울 것으로 예상. 가능한 강사님이 진행하고나서 해보는 것을 추천
- 오늘내일로는 이진탐색트리 완성이 아니라서 체크박스 체크는 추후에 완성 하고 하는걸로!

- (과제) Clear함수 재귀로 구현 (O)
- 링크드 리스트 front, back 구현 후 BFS와 DFS 출력

- iterator 구현
- begin, end 구현
- > 연산자 오버로딩 구현
- 중위순회 ++ -- 오버로딩 구현

---

1. 클래스, 구조체와 멤버

### Pair (struct)(O)

	- 멤버
		1) 탐색 시 사용되는 키 값
		2) 실제 데이터

### Node (struct)(O)

	- 멤버 
		1) Pair의 데이터를 담고 있는 공간
		2) 인덱스 별로 다른 Node의 주소를 담고있는 Node*[3]배열
			0 -> 부모 노드
			1 -> 왼 쪽 자식 노드
			2 -> 오른 쪽 자식 노드

### BST (class) - Binary Search Tree, 이진 탐색 트리(O)

	 - 멤버
		1) 루트 노드의 주소 (O)
			루트 노드부터 차근차근 내려가면서 접근
		2) 데이터의 개수 (O)
			데이터가 추가될 때 마다 개수가 증가하겠죠? 근데 어디에 쓰일지는 구현하면서 알아봐야겠음... 기억이 안나네요.


2. 함수 설계

### BST.insert(Pair) (O)

	이진 트리에는 데이터를 삽입할 때 insert() 함수를 사용.
	insert함수에 키 값과 데이터를 묶은 Pair를 인자로 넣어주면, 
	인자로 들어온 데이터를 이진 탐색 트리의 데이터 저장 구조인 Node에 삽입하고, 
	Node에 들어있는 Pair의 키 값을 기준으로 데이터를 탐색해 알맞은 자리에 저장한다.


### BST(), ~BST (O)
	
	생성자와 소멸자
	기본 생성자에는 딱히 해 줄 일이 없다.
	그냥 모든 인자를 nullptr로 초기화 해주면 되는거 아닐까?

	소멸자에는 모든 데이터를 삭제하는 BST.clear() 함수를 따로 구현하고, 그 함수가 들어간다.

### Node(), ~Node() (O)
	
	생성자와 소멸자
	기본 생성자에는 모든 인자를 nullptr로 초기화 해주면 될 듯 

	생성자 오버로딩으로 인자가 들어오는 버전을 만들자. insert 함수에서 쓸만할 것 같다...

	소멸자에는 할 일이 없다.
	차피 동적 할당 될 것이고 clear() 함수를 통해서 싹 다 날려버리기 때문이다.

### clear()

	BST의 소멸자로 사용 될 수 있고, 따로 호출해 사용할 수도 있다.
	만약 타겟의 왼 쪽 노드가 nullptr이 아니라면, 
		왼 쪽 노드의 주소를 인자로 넣고 재귀 함수를 실행한다.
	만약 타겟의 오른 쪽 노드가 nullptr이 아니라면, 
		오른 쪽 노드의 주소를 인자로 넣고 재귀 함수를 실행한다.

	이후, 자신이 들고있는 데이터를 delete해준다.

	이후, 함수를 종료하고 
	호출 된 스택을 차례차례 정리하면서 모든 데이터를 delete해준다.